/*
 * UmbraClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/xxCichyxx/UmbraClient
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import io.netty.buffer.Unpooled
import net.ccbluex.liquidbounce.UmbraClient
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.modules.combat.KillAura
import net.ccbluex.liquidbounce.features.module.modules.movement.Flight
import net.ccbluex.liquidbounce.features.module.modules.movement.LongJump
import net.ccbluex.liquidbounce.features.module.modules.movement.Speed
import net.ccbluex.liquidbounce.script.api.global.Chat
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Type
import net.ccbluex.liquidbounce.ui.font.Fonts
import net.ccbluex.liquidbounce.utils.*
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.MovementUtils.isMoving
import net.ccbluex.liquidbounce.utils.PacketUtils.handlePacket
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.extensions.tryJump
import net.ccbluex.liquidbounce.utils.inventory.InventoryUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.render.Stencil
import net.ccbluex.liquidbounce.utils.timing.MSTimer
import net.ccbluex.liquidbounce.value.*
import net.minecraft.client.gui.ScaledResolution
import net.minecraft.entity.Entity
import net.minecraft.entity.item.EntityBoat
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.init.Items
import net.minecraft.item.ItemStack
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.network.play.INetHandlerPlayClient
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.*
import net.minecraft.util.BlockPos
import net.minecraft.util.EnumFacing
import net.minecraft.util.ResourceLocation
import org.lwjgl.opengl.GL11.*
import java.awt.Color
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import java.lang.reflect.Field
import java.util.*
import java.util.concurrent.LinkedBlockingQueue
import kotlin.math.round
import kotlin.math.roundToInt
import kotlin.math.sqrt

object Disabler : Module("Disabler", Category.EXPLOIT, hideModule = false) {
    // Other
    val basicDisabler by BoolValue("BasicDisabler", false)
    val cancelC00Value by BoolValue("CancelC00", true) { basicDisabler }
    val cancelC0FValue by BoolValue("CancelC0F", true) { basicDisabler }
    val cancelC0AValue by BoolValue("CancelC0A", true) { basicDisabler }
    val cancelC0BValue by BoolValue("CancelC0B", true) { basicDisabler }
    val cancelC07Value by BoolValue("CancelC07", true) { basicDisabler }
    val cancelC13Value by BoolValue("CancelC13", true) { basicDisabler }
    val cancelC03Value by BoolValue("CancelC03", true) { basicDisabler }
    val c03NoMoveValue by BoolValue("C03-NoMove", true) { basicDisabler }
    val FakeLagDisabler by BoolValue("FakeLag", false)
    private val fakeLagPosValue = BoolValue("FakeLagPosition", true) {FakeLagDisabler}
    private val fakeLagBlockValue = BoolValue("FakeLagBlock", true) {FakeLagDisabler}
    private val fakeLagAttackValue = BoolValue("FakeLagAttack", true) {FakeLagDisabler}
    private val fakeLagSpoofValue = BoolValue("FakeLagC03Spoof", false) {FakeLagDisabler}
    private val lagDelayValue = IntegerValue("FakeLagLagDelay", 0, 0.. 2000) {FakeLagDisabler}
    private val lagDurationValue = IntegerValue("FakeLagLagDuration", 200, 100.. 1000) {FakeLagDisabler}
    val flagDisabler by BoolValue("Flag", false)
    private val flagMode = ListValue("Flag-Mode", arrayOf("Edit", "Packet"), "Edit") { flagDisabler }
    private val flagTick = IntegerValue("Flag-TickDelay", 25, 1.. 200) { flagDisabler }
    private val flagSilent = BoolValue("Flag-SilentMode", true) { flagDisabler }
    // =========================================================================== //

    val startSprint by BoolValue("StartSprint", true)

    // Grim
    private val grimPlace by BoolValue("GrimPlace", false)
    private val grimDebug by BoolValue("GrimDebug", false) { grimPlace }
    private val grimPlace2 by BoolValue("GrimPlace2", false)
    private val packetsG = LinkedBlockingQueue<Packet<*>>()
    private var pre = false
    private val c0e = BoolValue("ChestStealer", true) { grimPlace2 }
    private val c08 = BoolValue("PlaceBlock", true) { grimPlace2 }
    private val c0b = BoolValue("C0B", true) { grimPlace2 }
    private val grimSpectate by BoolValue("GrimSpectate", false)

    // Vulcan
    private val vulcanScaffold by BoolValue("VulcanScaffold", false)
    private val vulcanPacketTick by IntegerValue("PacketSilentSneakTick", 15, 1..20) { vulcanScaffold }
    private val vulcanstrafe by BoolValue("vulcanstrafe", false)
    private val vulcancombat by BoolValue("vulcancombat", false)
    private val compDecValue = BoolValue("VulcanDecrease", true) { vulcancombat }
    private val statDecValue =
        IntegerValue("VulcanDecreaseDelay", 1500, 500.. 2500) { vulcancombat && compDecValue.get() }
    private val dynamicValue = BoolValue("VulcanDynamicDelay", true) { vulcancombat }
    private val decDelayMinValue =
        IntegerValue("VulcanMinDelay", 4500, 2000.. 8000) { vulcancombat && dynamicValue.get() }
    private val decDelayMaxValue =
        IntegerValue("VulcanMaxDelay", 5500, 2000.. 8000) { vulcancombat && dynamicValue.get() }
    private val minBuffValue = IntegerValue("VulcanMinBuff", 5, 0.. 12) { vulcancombat }
    private val noC0BValue = BoolValue("NoC0BPacket", false) { vulcancombat }

    // Matrix
    private val MatrixGeyser by BoolValue("MatrixGeyser", false)
    private val Matrix by BoolValue("Matrix", false)
    private val matrixNoCheck = BoolValue("NoModuleCheck", false) {Matrix}
    private val matrixMoveFix = BoolValue("MoveFix", true) {Matrix}
    private val matrixMoveOnly = BoolValue("MoveOnly", false) {Matrix}
    private val matrixNoMovePacket = BoolValue("NoMovePacket", true) {Matrix}
    private val matrixHotbarChange = BoolValue("HotbarChange", true) {Matrix}
    private val oldmatrix by BoolValue("oldmatrix", false)

    // Verus
    val verusCombat by BoolValue("VerusCombat", false)
    private val onlyCombat by BoolValue("OnlyCombat", true) { verusCombat }
    val verusFly by BoolValue("VerusFly", false)
    private val verussemi by BoolValue("verussemi", false)
    private val verusfix by BoolValue("VerusFix", false)
    private val omniSprint13EValue = BoolValue("OmniSprint", true) {verusfix}
    private val scaffold14EValue = BoolValue("BlockPlace", true) {verusfix}
    private val fly4IValue = BoolValue("fly4I", true) {verusfix}
    private val latestverus by BoolValue("LatestVerus", false)
    private val verusLobbyValue = BoolValue("LobbyCheck", false) { latestverus || verussemi }
    private val verusFlagValue = BoolValue("Verus-Flag", true) { latestverus }
    private val verusSlientFlagApplyValue =
        BoolValue("Verus-SilentFlagApply", false) { latestverus }
    private val verusBufferSizeValue =
        IntegerValue("Verus-QueueActiveSize", 300, 0.. 1000) { latestverus }
    private val verusFlagDelayValue =
        IntegerValue("Verus-FlagDelay", 40, 40.. 120) { latestverus }
    private val verusAntiFlyCheck = BoolValue("Verus-AntiFlight", true) { latestverus }
    private val verusFakeInput = BoolValue("Verus-FakeInput", true) { latestverus }
    private val verusValidPos = BoolValue("Verus-ValidPosition", true) { latestverus }
    private val OldVerus by BoolValue("OldVerus", false)


    // Spartan
    private val SpartanCombat by BoolValue("SpartanCombat", false)

    // Buzz
    private val buzzsemi by BoolValue("buzzsemi", false)

    // AAC5
    private val aac5 by BoolValue("aac5", false)

    // IntaveFly
    val intaveFly by BoolValue("intaveFly", false)

    // Hypixel
    private val hypixelMotion by BoolValue("HypixelMotion", false)
    private val notWhenStarAvailable by BoolValue("NotWithStar", true) { hypixelMotion }

    // lol Fun Disablers
    private val GroundConvertDisabler by BoolValue("GroundConvert", false)
    private val MinelandDisabler by BoolValue("Mineland", false)
    private val validGroundValue = BoolValue("GroundYPos", true) {GroundConvertDisabler}
    private val yPortValue = BoolValue("GroundYOffset", true) {GroundConvertDisabler}
    private val noGroundValue = BoolValue("NoGround", true) {GroundConvertDisabler}
    private val onlyNegativeValue = BoolValue("GroundOnlyDownMotion", true)
    private val FlyingDisabler by BoolValue("Flying", false)
    private val RotDesync by BoolValue("RotDesync", false)
    private val ExploitFix by BoolValue("ExploitFix", false)
    private val invaildrotation = BoolValue("InvaildRotation-Fix", true) { ExploitFix }
    private val largemovement = BoolValue("InvaildMove-Fix", true) { ExploitFix }
    private val vanilladesync by BoolValue("vanilladesync", false)
    private val silentaccept by BoolValue("silentaccept", false)
    private val funcraftstaff by BoolValue("funcraftstaff", false)
    private val shotbow by BoolValue("shotbow", false)
    private val blockdrop by BoolValue("blockdrop", false)
    private val hycraft by BoolValue("Hycraft", false)
    private val invalidTeams = BoolValue("BlockTeams", true) {hycraft}
    private val invalidPosition = BoolValue("BlockInvalidPosition", true) {hycraft}
    private val inventoryspoof by BoolValue("inventoryspoof", false)
    private val jumpdisabler by BoolValue("jump", false)
    private val blockplacement by BoolValue("blockplacement", false)
    private val boat by BoolValue("boat", false)
    private val gwencombat by BoolValue("gwencombat", false)
    private val input by BoolValue("input", false)
    private val noswing by BoolValue("noswing", false)
    private val payload by BoolValue("payload", false)
    private val spectate by BoolValue("spectate", false)
    private val mushmc by BoolValue("mushmc", false)
    private val placechecks by BoolValue("placechecks", false)
    private val afkchecks by BoolValue("afkchecks", false)


    private var canModify = false
    private var shouldDelay = false
    private val packets = LinkedBlockingQueue<Packet<INetHandlerPlayClient>>()
    private val keepAlives = arrayListOf<C00PacketKeepAlive>()
    private val transactions = arrayListOf<C0FPacketConfirmTransaction>()
    private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()
    private val queueBus = LinkedList<Packet<INetHandlerPlayServer>>()

    // FakeLag
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()
    private var isSent = false
    private val fakeLagDelay = MSTimer()
    private val fakeLagDuration = MSTimer()

    //vulcan
    private var currentTrans = 0
    private var currentDelay = 5000
    private var currentBuffer = 4
    private var currentDec = -1
    private val lagTimer = MSTimer()
    private val decTimer = MSTimer()
    private var runReset = false
    //verus
    private var shouldActive = false
    private val msTimer = MSTimer()
    private fun isInventory(action: Short): Boolean = action in 1..99


    val noRotationDisabler by BoolValue("NoRotationDisabler", false)

    val modifyModeValue by ListValue("Mode", arrayOf("ConvertNull", "Spoof", "Zero", "SpoofZero", "Negative", "OffsetYaw", "Invalid"), "NoRotationDisabler") { noRotationDisabler }
    val offsetAmountValue by FloatValue("OffsetAmount", 6f, -180f.. 180f) { noRotationDisabler }

    val spigotSpam by BoolValue("SpigotSpam", false)
    val message by TextValue("Message", "/skill") { spigotSpam }
    private val debugValue by BoolValue("Debug", false)

    var x = 0.0
    var y = 0.0
    var z = 0.0
    var pitch = 0.0
    var yaw = 0.0
    var prevSlot = 0
    private var jam = 0


    private var transaction = false
    var isOnCombat = false

    private var flags = 0
    private var packetCount = 0
    private var airTicks = 0
    private var execute = false
    private var jump = false
    private fun shouldRun(): Boolean =
        mc.thePlayer != null && mc.thePlayer.inventory != null && (!verusLobbyValue.get() || !mc.thePlayer.inventory.hasItem(
            Items.compass
        )) && mc.thePlayer.ticksExisted > 5

    private val hasStar
        get() = InventoryUtils.findItem(36, 44, Items.nether_star) != null

    override fun onEnable() {
        shouldDelay = false
        if (boat) {
            debugMessage("Place 2 boats next to each other and right click to use it!")
        }
        if(FakeLagDisabler) {
            isSent = false
            packetBuffer.clear()
        }
    }


    fun isTerrainLoaded(): Boolean {
        return try {
            val netHandlerField: Field = mc.javaClass.getDeclaredField("netHandler")
            netHandlerField.isAccessible = true // Umożliwia dostęp do prywatnego pola
            val netHandler = netHandlerField.get(mc)

            // Uzyskanie dostępu do pola doneLoadingTerrain w klasie NetHandlerPlayClient
            val doneLoadingTerrainField: Field = netHandler.javaClass.getDeclaredField("doneLoadingTerrain")
            doneLoadingTerrainField.isAccessible = true // Umożliwia dostęp do prywatnego pola

            // Zwrócenie wartości doneLoadingTerrain
            doneLoadingTerrainField.getBoolean(netHandler)
        } catch (e: Exception) {
            e.printStackTrace()
            false // W przypadku błędu zwracamy false
        }
    }

    class Pack {
        var facingX: Float = 0.0F
        var facingY: Float = 0.0F
        var facingZ: Float = 0.0F
    }
    fun updatePacket(packet: Pack) {
        packet.facingX = packet.facingX.coerceIn(-1.00000F, 1.00000F)
        packet.facingY = packet.facingY.coerceIn(-1.00000F, 1.00000F)
        packet.facingZ = packet.facingZ.coerceIn(-1.00000F, 1.00000F)
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val player = mc.thePlayer ?: return
        val packet = event.packet
        if(verusfix){
            if (mc.thePlayer == null || mc.theWorld == null || event.isCancelled)
                return
            // fix ground check (4I)
            if (packet is C03PacketPlayer && packet !is C03PacketPlayer.C04PacketPlayerPosition && packet !is C03PacketPlayer.C06PacketPlayerPosLook) {
                if ((mc.thePlayer.motionY == 0.0 || (mc.thePlayer.onGround && mc.thePlayer.isCollidedVertically)) && !packet.onGround) {
                    packet.onGround = true
                    debugMessage("Packet C03 OnGround Fix")
                }
            }

            // some info things
            if (packet is C03PacketPlayer.C04PacketPlayerPosition) {
                x = packet.x
                y = packet.y
                z = packet.z
                jam = 0
            }

            if (packet is C03PacketPlayer.C05PacketPlayerLook) {
                yaw = packet.yaw.toDouble()
                pitch = packet.pitch.toDouble()
            }

            if (packet is C03PacketPlayer.C06PacketPlayerPosLook) {
                x = packet.x
                y = packet.y
                z = packet.z
                jam = 0

                yaw = packet.yaw.toDouble()
                pitch = packet.pitch.toDouble()
            }

            if (packet is C03PacketPlayer && packet !is C03PacketPlayer.C04PacketPlayerPosition && packet !is C03PacketPlayer.C06PacketPlayerPosLook) {
                jam++
                if (jam > 20) {
                    jam = 0
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(
                        C03PacketPlayer.C06PacketPlayerPosLook(
                            x,
                            y,
                            z,
                            yaw.toFloat(),
                            pitch.toFloat(),
                            packet.onGround
                        )
                    )
                    debugMessage("Packet C03 Spam Fix")
                }
            }

            // fix scaffold duplicated hotbar switch
            if (!mc.isSingleplayer && packet is C09PacketHeldItemChange) {
                if (packet.slotId == prevSlot) {
                    event.cancelEvent()
                    debugMessage("Packet C09 Duplicate Cancel")
                } else {
                    prevSlot = packet.slotId
                }
            }

            if (omniSprint13EValue.get() && packet is C0BPacketEntityAction) {
                event.cancelEvent()
                debugMessage("Packet C0B Check Cancel")
            }

            if (scaffold14EValue.get() && packet is C08PacketPlayerBlockPlacement) {
                val packet = Pack()
                packet.facingX = 1.5F  // Przykładowa wartość poza zakresem
                packet.facingY = -2.0F // Przykładowa wartość poza zakresem
                packet.facingZ = 0.5F
                updatePacket(packet)
                debugMessage("Packet C08 Placement Fix")
            }

            if (fly4IValue.get() && packet is C03PacketPlayer && !packet.onGround) {
                if (packet !is C03PacketPlayer.C04PacketPlayerPosition && packet !is C03PacketPlayer.C05PacketPlayerLook && packet !is C03PacketPlayer.C06PacketPlayerPosLook) {
                    packetCount++
                    if (packetCount >= 2) {
                        event.cancelEvent()
                        debugMessage("Packet C03 Flying Cancel")
                    }
                } else {
                    packetCount = 0
                }
            }
        }
        if(MinelandDisabler){
            if(packet is C0FPacketConfirmTransaction){
                event.cancelEvent()
            }
            if(packet is C03PacketPlayer && mc.thePlayer.onGround){
                event.cancelEvent()
            }
        }
        if(GroundConvertDisabler){
            if (packet is C03PacketPlayer) {
                val yPos = (packet.y / 0.015625).roundToInt() * 0.015625
                if (validGroundValue.get()) {
                    if (!onlyNegativeValue.get() || mc.thePlayer.motionY < 0) {
                        packet.y = yPos
                    }
                }
                if (yPortValue.get() && (mc.thePlayer.onGround || packet.onGround)) {
                    packet.y += 0.015625
                }
                if (noGroundValue.get()) {
                    packet.onGround = false
                }
            }
        }
        if(FlyingDisabler){
            if (packet is C03PacketPlayer) {
                val capabilities = PlayerCapabilities()
                capabilities.disableDamage = false
                capabilities.isFlying = true
                capabilities.allowFlying = false
                capabilities.isCreativeMode = false
                mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                debugMessage("Send Packet C13")
            }
        }
        if(FakeLagDisabler) {
            if (fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) {
                if (isSent && fakeLagSpoofValue.get()) {
                    PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                    if (lagDurationValue.get() >= 300) PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                    isSent = false
                }
                if (packet is C00PacketKeepAlive || packet is C0FPacketConfirmTransaction) {
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
                if (fakeLagAttackValue.get() && (packet is C02PacketUseEntity || packet is C0APacketAnimation)) {
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    if (packet is C0APacketAnimation) return
                }
                if (fakeLagBlockValue.get() && (packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement || packet is C0APacketAnimation)) {
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
                if (fakeLagPosValue.get() && (packet is C03PacketPlayer || packet is C0BPacketEntityAction)) {
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
            }
        }
        if (afkchecks) {
            // Sprawdzenie, czy LongJump jest aktywny
            val longJumpModule = UmbraClient.moduleManager.getModule(LongJump::class.java)
            val killAuraModule = UmbraClient.moduleManager.getModule(KillAura::class.java)

            // Sprawdzenie stanu LongJump i trybu
            if (longJumpModule?.state == true || killAuraModule?.state == true && killAuraModule.target != null) {
                debugMessage("unavailable")
            } else {
                if (packet is C03PacketPlayer) {
                    // Sprawdzenie, czy gracz nie jest w ruchu
                    if (mc.thePlayer.motionY == 0.0 || mc.thePlayer.onGround || mc.thePlayer.isCollidedVertically) {
                        packet.onGround = true
                        debugMessage("fix ground")
                    }
                }

                if (packet is C03PacketPlayer) {
                    // Sprawdzenie, czy to nie jest jeden z określonych typów pakietów
                    if (packet !is C04PacketPlayerPosition &&
                        packet !is C05PacketPlayerLook &&
                        packet !is C06PacketPlayerPosLook) {
                        packetCount++
                        if (packetCount >= 2) {
                            event.cancelEvent()
                            debugMessage("cancel nigga 2")
                        }
                    } else {
                        packetCount = 0
                        debugMessage("set 0")
                    }
                }
            }
        }
        if (placechecks) {
            if (packet is C08PacketPlayerBlockPlacement && !mc.isIntegratedServerRunning) {
                event.cancelEvent()
                PacketUtils.sendPacketNoEvent(
                    C08PacketPlayerBlockPlacement(
                        packet.position,
                        packet.placedBlockDirection,
                        null,
                        packet.placedBlockOffsetX,
                        packet.placedBlockOffsetY,
                        packet.placedBlockOffsetZ
                    )
                )
                debugMessage("replaced placement packet")
            }
        }
        if (mushmc) {
            if (packet is C16PacketClientStatus || packet is C0APacketAnimation || packet is S42PacketCombatEvent || packet is S3EPacketTeams) {
                event.cancelEvent()
                debugMessage("funny packet")
            }
            mc.thePlayer.capabilities.isCreativeMode = true
        }
        if (spectate) {
            if (packet is C03PacketPlayer) {
                packet.onGround = false

                mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                debugMessage("Packet C18 + C13")
            }
            if (packet is C13PacketPlayerAbilities) {
                debugMessage("Packet C13")
                packet.isFlying = true
                packet.isInvulnerable = true
                packet.isAllowFlying = true
                packet.isCreativeMode = false
            }
        }
        if (noswing) {
            if (packet is C0APacketAnimation) {
                event.cancelEvent()
                debugMessage("cancelled c0a")
            }
        }
        if (input) {
            PacketUtils.sendPacketNoEvent(C0CPacketInput(0.98f, 0f, true, true))
            debugMessage("input")
        }
        if (gwencombat) {
            if (packet is C00PacketKeepAlive) {
                event.cancelEvent()
                PacketUtils.sendPacketNoEvent(
                    C00PacketKeepAlive(
                        packet.key - RandomUtils.nextInt(
                            1000,
                            2147483647
                        )
                    )
                )
                debugMessage("cancel c00")
            }
        }
        if (boat) {
            if (mc.thePlayer.ridingEntity != null) {
                canModify = true
            }
            if (canModify && packet is C03PacketPlayer) {
                packet.onGround = true
            }
        }

        if (inventoryspoof|| shotbow) {
            PacketUtils.sendPacketNoEvent(C0DPacketCloseWindow())
        }
        if (jumpdisabler) {
            if (packet is C03PacketPlayer) {
                val capabilities = PlayerCapabilities()
                capabilities.disableDamage = false
                capabilities.isFlying = true
                capabilities.allowFlying = false
                capabilities.isCreativeMode = false
                mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                debugMessage("jump added")
            }
        }
        if (shotbow) {
            if (packet is C0DPacketCloseWindow) {
                event.cancelEvent()
                debugMessage("Activated Disabler!")
            }
            if (packet is C03PacketPlayer)
                packet.onGround = true
            if (packet is S08PacketPlayerPosLook) {
                if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return
                val x = packet.getX() - mc.thePlayer.posX
                val y = packet.getY() - mc.thePlayer.posY
                val z = packet.getZ() - mc.thePlayer.posZ
                val diff = sqrt(x * x + y * y + z * z)
                if (diff <= 20) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            packet.x,
                            packet.y,
                            packet.z,
                            packet.yaw,
                            packet.pitch,
                            true
                        )
                    )
                    debugMessage("modified c06")
                    PacketUtils.sendPacketNoEvent(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY + 0.2,
                            mc.thePlayer.posZ,
                            false
                        )
                    )
                    PacketUtils.sendPacketNoEvent(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    debugMessage("cancel c04")
                }
            }
        }
        if (inventoryspoof) {
            if (packet is C0DPacketCloseWindow) {
                event.cancelEvent()
                debugMessage("spoof inventory")
            }
        }
        if (hycraft) {
            if(packet is S3EPacketTeams && invalidTeams.get()) {
                debugMessage("Blocked Invalid S3EPacketTeams")
                event.cancelEvent()
            }
            if (packet is S08PacketPlayerPosLook && invalidPosition.get()) {
                val x = packet.x
                val y = packet.y
                val z = packet.z

                if (x >= 200000 || x <= -200000 ||
                    y >= 200000 || y <= -200000 ||
                    z >= 200000 || z <= -200000) {
                    mc.netHandler.networkManager.sendPacket(C03PacketPlayer.C06PacketPlayerPosLook(x, y, z, packet.getYaw(), packet.getPitch(), false)  )
                    debugMessage("Blocked Invalid S08PacketPlayerPosLook")
                    event.cancelEvent()
                }
            }
        }

        if (blockdrop) {
            if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives[keepAlives.size - 1])) {
                debugMessage("c00 added")
                keepAlives.add(packet)
                event.cancelEvent()
            }
            if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions[transactions.size - 1])) {
                debugMessage("c0f added")
                transactions.add(packet)
                event.cancelEvent()
            }
            if (packet is C13PacketPlayerAbilities) {
                event.cancelEvent()
            }
        }

        if (funcraftstaff) {
            if (packet is C03PacketPlayer) {
                mc.thePlayer.sendQueue.networkManager.sendPacket(C00PacketKeepAlive(-2))
                debugMessage("LOL")
            }
        }

        if (silentaccept) {
            if (packet is C03PacketPlayer) {
                val yPos = round(mc.thePlayer.posY / 0.015625) * 0.015625
                mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)

                if (mc.thePlayer.ticksExisted % 45 == 0) {
                    debugMessage("flag")
                    PacketUtils.sendPacketNoEvent(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    PacketUtils.sendPacketNoEvent(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY - 11.725,
                            mc.thePlayer.posZ,
                            false
                        )
                    )
                    PacketUtils.sendPacketNoEvent(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                }
            }

            if (packet is S08PacketPlayerPosLook) {
                if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

                val x = packet.getX() - mc.thePlayer.posX
                val y = packet.getY() - mc.thePlayer.posY
                val z = packet.getZ() - mc.thePlayer.posZ
                val diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            packet.getX(),
                            packet.getY(),
                            packet.getZ(),
                            packet.getYaw(),
                            packet.getPitch(),
                            true
                        )
                    )

                    debugMessage("silent s08 accept")
                }
            }

            if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                repeat(4) {
                    packetQueue.add(packet)
                }
                event.cancelEvent()
                debugMessage("c0f dupe: 4x")
            }
        }

        if (vanilladesync) {
            if (packet is S08PacketPlayerPosLook) {
                if (!isTerrainLoaded()) {
                    debugMessage("not loaded terrain yet")
                    return
                }
                event.cancelEvent()
                PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(packet.x, packet.y, packet.z, false))
                mc.thePlayer.setPosition(packet.x, packet.y, packet.z)
                debugMessage("silent setback")
            }
        }

        if(ExploitFix){
            if(packet is S08PacketPlayerPosLook) {
                if(invaildrotation.get()) {
                    if(packet.yaw > 180f || packet.yaw < -180f || packet.pitch < 90f + -500f || packet.pitch > 90f + 500f) {
                        debugMessage("Cancelled invaild rotation")
                        event.cancelEvent()
                    }
                }
                if(largemovement.get()) {
                    if(packet.x > 20000000f || packet.y > 20000000f || packet.z > 20000000f) {
                        debugMessage("Cancelled large movement teleport")
                        event.cancelEvent()
                    }
                }
            }
        }

        if(RotDesync){
            if (packet is S08PacketPlayerPosLook) {
                if (!isTerrainLoaded()) {
                    debugMessage("not loaded terrain yet")
                    return
                }
                event.cancelEvent()
                PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(packet.x, packet.y, packet.z, false))
                mc.thePlayer.setPosition(packet.x, packet.y, packet.z)
                debugMessage("silent setback")
            }
        }

        if (aac5) {
            val packetPlayerAbilities = C13PacketPlayerAbilities()
            packetPlayerAbilities.isFlying = true
            PacketUtils.sendPacketSilent(packetPlayerAbilities)
            if (mc.thePlayer.ticksExisted % 40 == 0) PacketUtils.sendPacketSilent(
                C04PacketPlayerPosition(
                    0.0,
                    258382.0,
                    0.0,
                    true
                )
            )
            debugMessage("Funny packet Activated!")
        }

        if (buzzsemi) {
            if (packet is C0FPacketConfirmTransaction) {
                repeat(5) {
                    packetQueue.add(packet)
                }
                event.cancelEvent()
                debugMessage("c0f dupe: 5x")
            }
        }

        if (SpartanCombat) {
            if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives[keepAlives.size - 1])) {
                debugMessage("c00 added")
                keepAlives.add(packet)
                event.cancelEvent()
            }
            if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions[transactions.size - 1])) {
                debugMessage("c0f added")
                transactions.add(packet)
                event.cancelEvent()
            }
        }

        if(OldVerus){
            if (packet is C03PacketPlayer) {
                val yPos = round(mc.thePlayer.posY / 0.015625) * 0.015625
                mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)

                if (mc.thePlayer.ticksExisted % 45 == 0) {
                    debugMessage("flag")
                    PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 11.725, mc.thePlayer.posZ, false))
                    PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                }
            }

            if (packet is S08PacketPlayerPosLook) {
                if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

                var x = packet.getX() - mc.thePlayer.posX
                var y = packet.getY() - mc.thePlayer.posY
                var z = packet.getZ() - mc.thePlayer.posZ
                var diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), true))

                    debugMessage("silent s08 accept")
                }
            }

            if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                repeat (4) {
                    packetQueue.add(packet)
                }
                event.cancelEvent()
                debugMessage("c0f dupe: 4x")
            }
        }

        if (latestverus) {
            if (!shouldRun()) {
                msTimer.reset()
                packetQueue.clear()
                return
            }

            if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                packetQueue.add(packet)
                event.cancelEvent()
                if (packetQueue.size > verusBufferSizeValue.get()) {
                    if (!shouldActive) {
                        shouldActive = true
                        debugMessage("Successfully Verus Disabled!")
                    }
                    PacketUtils.sendPacketNoEvent(packetQueue.poll())
                }
                debugMessage("c0f, ${packetQueue.size}")
            }

            if (packet is C0BPacketEntityAction) {
                event.cancelEvent()
                debugMessage("ignored packet action")
            }

            if (packet is C03PacketPlayer) {
                if (verusFlagValue.get() && mc.thePlayer.ticksExisted % verusFlagDelayValue.get() == 0) {
                    debugMessage("modified c03")
                    packet.y -= 11.015625 // just phase into ground instead (minimum to flag)
                    packet.onGround = false
                    packet.isMoving = false
                }
                if (verusValidPos.get()) {
                    if (packet.y % 0.015625 == 0.0)
                        packet.onGround = true
                }
            }

            if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
                val x = packet.x - mc.thePlayer.posX
                val y = packet.y - mc.thePlayer.posY
                val z = packet.z - mc.thePlayer.posZ
                val diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    // verus, why
                    debugMessage("flag silent accept")
                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            packet.x,
                            packet.y,
                            packet.z,
                            packet.getYaw(),
                            packet.getPitch(),
                            false
                        )
                    )
                }
            }
        }

        if (verussemi) {
            if (!shouldRun()) {
                queueBus.clear()
                return
            }

            if (packet is C0BPacketEntityAction) {
                event.cancelEvent()
                debugMessage("cancel action")
            }

            if (packet is S08PacketPlayerPosLook) {
                if (mc.thePlayer.getDistance(packet.x, packet.y, packet.z) < 8) {
                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            packet.x,
                            packet.y,
                            packet.z,
                            packet.yaw,
                            packet.pitch,
                            false
                        )
                    )
                    event.cancelEvent()
                    debugMessage("silent flag")
                }
            }

            if (packet is C00PacketKeepAlive || (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid))) {
                queueBus.add(packet as Packet<INetHandlerPlayServer>)
                event.cancelEvent()

                debugMessage("c0f or c00, ${queueBus.size}")

                if (queueBus.size > 300) {
                    PacketUtils.sendPacketNoEvent(queueBus.poll())
                    debugMessage("poll")
                }
            }

            if (packet is C03PacketPlayer) {
                if (mc.thePlayer.ticksExisted % 20 == 0) {
                    PacketUtils.sendPacketNoEvent(C0CPacketInput(0.98f, 0.98f, false, false))
                    debugMessage("c18 and c0c")
                }

                if (mc.thePlayer.ticksExisted % 45 == 0) {
                    packet.y = -0.015625
                    packet.onGround = false
                    packet.isMoving = false
                    debugMessage("flag packet")
                }
            }
        }

        if (oldmatrix) {
            if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
                try {
                    val b = ByteArrayOutputStream()
                    val _out = DataOutputStream(b)
                    _out.writeUTF(mc.thePlayer.gameProfile.name)
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.netHandler.addToSendQueue(C17PacketCustomPayload("matrix:geyser", buf))

                    debugMessage("Sent Matrix spoof packet.")
                } catch (e: IOException) {
                    debugMessage("Error occurred.")
                }
            }
        }

        if(Matrix){
            if (matrixNoCheck.get() || UmbraClient.moduleManager.getModule(Speed::class.java)!!.state || UmbraClient.moduleManager.getModule(
                    Flight::class.java)!!.state) {
                if (packet is C03PacketPlayer) {
                    if (matrixNoMovePacket.get() && !packet.isMoving) {
                        event.cancelEvent()
                        displayChatMessage("no move, cancelled")
                        return
                    }
                    if (matrixMoveFix.get()) {
                        packet.onGround = true
                        if (!packet.rotating) {
                            packet.rotating = true
                            packet.yaw = mc.thePlayer.rotationYaw
                            packet.pitch = mc.thePlayer.rotationPitch
                        }
                    }
                }
            }
        }
        if(MatrixGeyser){
            if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
                try {
                    val b = ByteArrayOutputStream()
                    val _out = DataOutputStream(b)
                    _out.writeUTF(mc.thePlayer.gameProfile.getName())
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.netHandler.addToSendQueue(C17PacketCustomPayload("matrix:geyser", buf))
                    debugMessage("Sent Matrix Geyser spoof packet.")
                } catch (e: IOException) {
                    debugMessage("Error occurred.")
                }
            }
        }

        if (vulcancombat) {
            if (packet is C0BPacketEntityAction && noC0BValue.get()) {
                event.cancelEvent()
                debugMessage("C0B-EntityAction CANCELLED")
            }
            if (packet is C0FPacketConfirmTransaction) {
                BlinkUtils.setBlinkState(packetTransaction = false)
                val transUID = (packet.uid).toInt()
                if (transUID >= -25767 && transUID <= -24769) {
                    BlinkUtils.setBlinkState(packetTransaction = true)
                    debugMessage("C0F-PingTickCounter IN ${BlinkUtils.bufferSize(packetType = "C0FPacketConfirmTransaction")}")
                } else if (transUID == -30000) {
                    BlinkUtils.setBlinkState(packetTransaction = true)
                    debugMessage("C0F-OnSpawn IN ${BlinkUtils.bufferSize(packetType = "C0FPacketConfirmTransaction")}")
                }
            }
        }

        if(vulcanstrafe){
            if (packet is C03PacketPlayer) {
                mc.thePlayer.sendQueue.addToSendQueue(
                    C07PacketPlayerDigging(
                        C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK, BlockPos(
                            mc.thePlayer.posX, mc.thePlayer.posY - 1.0, mc.thePlayer.posZ
                        ), EnumFacing.UP
                    )
                )
            }
        }

        if(grimPlace2){
            if (packet is C0EPacketClickWindow && c0e.get()) {
                if (!pre) {
                    event.cancelEvent()
                    packetsG.add(packet)
                    debugMessage("Sending C0E")
                }
            }
            if (packet is C0BPacketEntityAction && c0b.get()) {
                if (!pre) {
                    event.cancelEvent()
                    packetsG.add(packet)
                    debugMessage("Sendig C0B")
                }
            }
            if (packet is C08PacketPlayerBlockPlacement && c08.get()) {
                if (!pre) {
                    event.cancelEvent()
                    packetsG.add(packet)
                    debugMessage("Seding C08")
                }
            }
        }

        if(grimSpectate){
            if (packet is S08PacketPlayerPosLook) {
                if (mc.thePlayer.capabilities.isFlying) {
                    shouldDelay = true
                    debugMessage("Start Canceling")
                }
            }

            if (packet is S32PacketConfirmTransaction && shouldDelay) {
                event.cancelEvent()
                packets.add(packet as Packet<INetHandlerPlayClient>)
            }
        }

        // Basic Disabler
        if (basicDisabler) {
            when (packet) {
                is C00PacketKeepAlive -> if (cancelC00Value) {
                    event.cancelEvent()
                    debugMessage("Cancel C00-KeepAlive")
                }
                is C0FPacketConfirmTransaction -> if (cancelC0FValue) {
                    event.cancelEvent()
                    debugMessage("Cancel C0F-Transaction")
                }
                is C0APacketAnimation -> if (cancelC0AValue) {
                    event.cancelEvent()
                    debugMessage("Cancel C0A-Swing")
                }
                is C0BPacketEntityAction -> if (cancelC0BValue) {
                    event.cancelEvent()
                    debugMessage("Cancel C0B-Action")
                }
                is C07PacketPlayerDigging -> if (cancelC07Value) {
                    event.cancelEvent()
                    debugMessage("Cancel C07-Digging")
                }
                is C13PacketPlayerAbilities -> if (cancelC13Value) {
                    event.cancelEvent()
                    debugMessage("Cancel C13-Abilities")
                }
                is C03PacketPlayer -> if (cancelC03Value && !(packet is C03PacketPlayer.C04PacketPlayerPosition || packet is C03PacketPlayer.C05PacketPlayerLook || packet is C03PacketPlayer.C06PacketPlayerPosLook)) {
                    if (c03NoMoveValue && isMoving) return
                    event.cancelEvent()
                    debugMessage("Cancel C03-Flying")
                }
            }
        }
        if(flagDisabler){
            if (packet is C03PacketPlayer && flagMode.get().equals("edit", true) && mc.thePlayer.ticksExisted > 0 && mc.thePlayer.ticksExisted % flagTick.get() == 0)
            {
                packet.isMoving = false
                packet.onGround = false
                packet.y = -0.08
            }
            if (packet is S08PacketPlayerPosLook && flagSilent.get()) {
                if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

                var x = packet.getX() - mc.thePlayer.posX
                var y = packet.getY() - mc.thePlayer.posY
                var z = packet.getZ() - mc.thePlayer.posZ
                var diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), true))
                }
            }
        }

        // NoRotationDisabler
        if (noRotationDisabler && packet is C03PacketPlayer) {

            when (modifyModeValue) {
                "ConvertNull" -> {
                    if (packet.isMoving) {
                        sendPacket(
                            C03PacketPlayer.C04PacketPlayerPosition(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.onGround
                            )
                        )
                    } else {
                        sendPacket(C03PacketPlayer(packet.onGround))
                    }
                    event.cancelEvent()
                }

                "Spoof" -> {
                    if (packet.getRotating()) {
                        packet.yaw = player.rotationYaw
                        packet.pitch = player.rotationPitch
                    }
                }

                "Zero" -> {
                    if (packet.getRotating()) {
                        packet.yaw = 0.0f
                        packet.pitch = 0.0f
                    }
                }

                "SpoofZero" -> {
                    if (packet.isMoving) {
                        sendPacket(
                            C03PacketPlayer.C06PacketPlayerPosLook(
                                packet.x,
                                packet.y,
                                packet.z,
                                0.0f,
                                0.0f,
                                packet.onGround
                            )
                        )
                    } else {
                        sendPacket(
                            C03PacketPlayer.C06PacketPlayerPosLook(
                                player.posX,
                                player.posY,
                                player.posZ,
                                0.0f,
                                0.0f,
                                packet.onGround
                            )
                        )
                    }
                    event.cancelEvent()
                }

                "Negative" -> {
                    if (packet.getRotating()) {
                        packet.yaw = -packet.yaw
                        packet.pitch = -packet.pitch
                    }
                }

                "OffsetYaw" -> {
                    if (packet.getRotating()) {
                        packet.yaw += offsetAmountValue
                    }
                }
            }
        }

        /**
         * Working on Hypixel (Watchdog)
         * Tested on: play.hypixel.net
         * Credit: @localp / Nextgen
         * Original: @billionaire
         */
        if (hypixelMotion) {
            when (packet) {
                is S07PacketRespawn -> {
                    flags = 0
                    execute = false
                    jump = true
                }

                is S08PacketPlayerPosLook -> {
                    if (++flags >= 20) {
                        execute = false
                        flags = 0
                    }
                }
            }
        }

        if (grimPlace) {
            if (packet is C08PacketPlayerBlockPlacement && packet.placedBlockDirection in 0..5) {
                event.cancelEvent()
                sendPacket(
                    C08PacketPlayerBlockPlacement(
                        packet.position,
                        6 + packet.placedBlockDirection * 7,
                        packet.stack,
                        packet.placedBlockOffsetX,
                        packet.placedBlockOffsetY,
                        packet.placedBlockOffsetZ
                    )
                )

                if (grimDebug) {
                    displayChatMessage("§cModify §aPlace §cPacket§7.")
                }
            }
        }

        if (intaveFly) {
            if (packet is S08PacketPlayerPosLook) {
                if (player.capabilities.isFlying) {
                    shouldDelay = true
                    displayChatMessage("§cStart Canceling IntaveFly")
                }
            }

            if (packet is S32PacketConfirmTransaction && shouldDelay) {
                event.cancelEvent()
                packets.add(packet as Packet<INetHandlerPlayClient>)
            }
        }

        if (verusCombat) {
            if (player.ticksExisted <= 20) {
                isOnCombat = false
                return
            }

            if (onlyCombat && !isOnCombat) {
                return
            }

            /**
             * Works by just simply ignore transaction and not accepting them and send invalid one
             * to bypass Verus cancel transaction "patch" (not sending transaction for too long)
             * This could work on other anti-cheat that don't have a proper transaction handling system
             * But this will mostly be used on Verus, disabled any combat check related to transaction.
             *
             * Credit: @ghost / LB Nextgen
             */
            if (packet is S32PacketConfirmTransaction) {
                event.cancelEvent()
                sendPacket(C0FPacketConfirmTransaction(if (transaction) 1 else -1, if (transaction) -1 else 1, transaction), triggerEvent = false)
                transaction = !transaction
            }
        }
    }
    @Override
    fun onPostMotion(event: PostMotionEvent) {
        if(Matrix){
            if (!matrixMoveOnly.get() || isMoving)
                if (matrixNoCheck.get() || UmbraClient.moduleManager[Flight::class.java]!!.state || UmbraClient.moduleManager[Speed::class.java]!!.state) {
                    var changed = false
                    if (matrixHotbarChange.get()) for (i in 0..8) {
                        // find an empty inventory slot
                        if(mc.thePlayer.inventory.mainInventory[i] == null && i != mc.thePlayer.inventory.currentItem) {
                            PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(i))
                            changed = true
                            displayChatMessage("found empty slot $i, switching")
                            break
                        }
                    }

                    RotationUtils.serverRotation?.let { C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, it.yaw, RotationUtils.serverRotation!!.pitch, mc.thePlayer.onGround) }
                        ?.let { PacketUtils.sendPacketNoEvent(it) }
                    mc.netHandler.addToSendQueue(C08PacketPlayerBlockPlacement(BlockPos(-1, -1, -1), -1, null, 0f, 0f, 0f))
                    displayChatMessage("sent placement")

                    if (changed) {
                        PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                        displayChatMessage("switched back")
                    }
                }
        }
    }

    @EventTarget
    fun onJump(event: JumpEvent) {
        if (!hypixelMotion) return

        if (event.eventState == EventState.POST) {
            if (!jump) return
            jump = false
            execute = true
        }
    }

    @EventTarget
    fun onMotion(event: MotionEvent) {
        val player = mc.thePlayer ?: return

        if (payload) {
            if (event.eventState != EventState.POST) {
                PacketUtils.sendPacketNoEvent(
                    C17PacketCustomPayload(
                        "40413eb1",
                        PacketBuffer(Unpooled.wrappedBuffer(byteArrayOf(8, 52, 48, 52, 49, 51, 101, 98, 49)))
                    )
                )
                debugMessage("funny")
            }
        }

        if(grimPlace2){
            pre = event.eventState == EventState.PRE
            if (event.eventState == EventState.PRE) {
                try {
                    while (!packetsG.isEmpty()) {
                        mc.netHandler!!.addToSendQueue(packetsG.take())
                        debugMessage("Sending queued packets")
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }

        if (!hypixelMotion) return
        if (event.eventState != EventState.PRE) return
        if (notWhenStarAvailable && hasStar) return

        // TODO: Add Warning Message

        when {
            player.onGround -> airTicks = 0
            else -> airTicks++
        }

        if (execute && airTicks >= 10) {
            if (airTicks % 2 == 0) {
                event.x += 0.095
            }
            player.setVelocity(0.0, 0.0, 0.0)
        }
    }
    private fun getNearBoat(): Entity? {
        val entities = mc.theWorld.loadedEntityList
        for (entity_ in entities) {
            if (entity_ is EntityBoat) {
                if (entity_ != mc.thePlayer.ridingEntity) {
                    return entity_
                }
            }
        }
        return null
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        val player = mc.thePlayer ?: return

        if(FakeLagDisabler){
            if (!fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) fakeLagDuration.reset()
            // Send
            if (fakeLagDuration.hasTimePassed(lagDurationValue.get().toLong())) {
                fakeLagDelay.reset()
                fakeLagDuration.reset()
                for (packet in packetBuffer) {
                    PacketUtils.sendPacketNoEvent(packet)
                }
                debugMessage("Release buf(size=${packetBuffer.size})")
                isSent = true
                packetBuffer.clear()
            }
        }

        if (boat) {
            if (mc.thePlayer.ridingEntity != null) {
                mc.thePlayer.rotationPitch = (90.0).toFloat()
                mc.thePlayer.swingItem()
                mc.playerController.attackEntity(mc.thePlayer, mc.thePlayer.ridingEntity)
                mc.thePlayer.swingItem()
                mc.playerController.attackEntity(mc.thePlayer, getNearBoat())
                canModify = true
                debugMessage("Destroy Boat")
            }
        }

        if (blockplacement) {
            PacketUtils.sendPacketNoEvent(
                C08PacketPlayerBlockPlacement(
                    BlockPos(Double.NaN, Double.NaN, Double.NaN),
                    1,
                    null,
                    0f,
                    0f,
                    0f
                )
            )
            debugMessage("BlockPlacement")
        }

        if (blockdrop) {
            if (msTimer.hasTimePassed(3000L) && keepAlives.size > 0 && transactions.size > 0) {
                PacketUtils.sendPacketNoEvent(keepAlives[keepAlives.size - 1])
                PacketUtils.sendPacketNoEvent(transactions[transactions.size - 1])

                debugMessage("c00 no.${keepAlives.size - 1} sent.")
                debugMessage("c0f no.${transactions.size - 1} sent.")
                keepAlives.clear()
                transactions.clear()
                msTimer.reset()
            }
        }

        if (silentaccept) {
            if (mc.thePlayer.ticksExisted % 180 == 0) {
                while (packetQueue.size > 22) {
                    PacketUtils.sendPacketNoEvent(packetQueue.poll())
                }
                debugMessage("pushed queue until size < 22.")
            }
        }

        if (SpartanCombat) {
            if (msTimer.hasTimePassed(3000L) && keepAlives.size > 0 && transactions.size > 0) {
                PacketUtils.sendPacketNoEvent(keepAlives[keepAlives.size - 1])
                PacketUtils.sendPacketNoEvent(transactions[transactions.size - 1])
                debugMessage("c00 no.${keepAlives.size - 1} sent.")
                debugMessage("c0f no.${transactions.size - 1} sent.")
                keepAlives.clear()
                transactions.clear()
                msTimer.reset()
            }
        }
        if(OldVerus){
            if (mc.thePlayer.ticksExisted % 180 == 0) {
                while (packetQueue.size > 22) {
                    PacketUtils.sendPacketNoEvent(packetQueue.poll())
                }
                debugMessage("pushed queue until size < 22.")
            }
        }

        if (hypixelMotion) {
            if (jump) {
                player.tryJump()
            }
        }
        if (latestverus) {
            if (verusAntiFlyCheck.get() && !shouldActive) {
                val flightMod = UmbraClient.moduleManager[Flight::class.java]!!
                if (flightMod.state) {
                    flightMod.state = false
                    debugMessage("You can't fly before successful activation")
                    debugMessage("no fly allowed")
                }
            }
            if (!shouldRun()) {
                msTimer.reset()
                packetQueue.clear()
                return
            }
            if (mc.thePlayer.ticksExisted % 15 == 0) {
                if (verusFakeInput.get()) {
                    mc.netHandler.addToSendQueue(
                        C0CPacketInput(
                            mc.thePlayer.moveStrafing.coerceAtMost(0.98F),
                            mc.thePlayer.moveForward.coerceAtMost(0.98F),
                            mc.thePlayer.movementInput.jump,
                            mc.thePlayer.movementInput.sneak
                        )
                    )
                    debugMessage("c0c")
                }
            }
        }
        if (vulcancombat) {
            if (runReset) {
                runReset = false
                PacketUtils.sendPacketNoEvent(
                    C0BPacketEntityAction(
                        mc.thePlayer,
                        C0BPacketEntityAction.Action.STOP_SPRINTING
                    )
                )
            }
            if (lagTimer.hasTimePassed(currentDelay.toLong()) && BlinkUtils.bufferSize(packetType = "C0FPacketConfirmTransaction") > currentBuffer) {
                updateLagTime()
                BlinkUtils.releasePacket(packetType = "C0FPacketConfirmTransaction", minBuff = currentBuffer)
                debugMessage("C0F-PingTickCounter RELEASE")
            }
            if (decTimer.hasTimePassed(currentDec.toLong()) && currentDec > 0) {
                BlinkUtils.releasePacket(packetType = "C0FPacketConfirmTransaction", amount = 1)
                debugMessage("C0F-PingTickCounter DECREASE")
                decTimer.reset()
            }
        }

        if (verusFly) {
            if (!isOnCombat && !player.isDead) {
                val pos = player.position.add(0, if (player.posY > 0) -255 else 255, 0) ?: return

                sendPacket(
                    C08PacketPlayerBlockPlacement(
                        pos,
                        256,
                        ItemStack(Items.water_bucket),
                        0F,
                        0.5F + Math.random().toFloat() * 0.44F,
                        0F
                    )
                )
            } else {
                isOnCombat = false
            }
        }

        if (vulcanScaffold) {
            if (!(player.isInWater || player.isInLava || player.isDead || player.isOnLadder)) {
                if (isMoving && player.ticksExisted % vulcanPacketTick == 0) {
                    sendPacket(C0BPacketEntityAction(player, C0BPacketEntityAction.Action.START_SNEAKING))
                    sendPacket(C0BPacketEntityAction(player, C0BPacketEntityAction.Action.STOP_SNEAKING))
                }
            }
        }
        if(flagDisabler){
            if (flagMode.get().equals("packet", true) && mc.thePlayer.ticksExisted > 0 && mc.thePlayer.ticksExisted % flagTick.get() == 0) {
                PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, -0.08, mc.thePlayer.posZ, mc.thePlayer.onGround))
            }
        }
    }
    private fun updateLagTime() {
        decTimer.reset()
        lagTimer.reset()
        currentDelay =
            if (dynamicValue.get()) RandomUtils.nextInt(decDelayMinValue.get(), decDelayMaxValue.get()) else 5000
        currentDec = if (compDecValue.get()) statDecValue.get() else -1
        currentBuffer = minBuffValue.get()
    }

    override fun onDisable() {
        airTicks = 0
        while (!packets.isEmpty()) {
            handlePacket(packets.take() as Packet<INetHandlerPlayClient?>)
        }
        if (vulcancombat) {
            updateLagTime()
            BlinkUtils.releasePacket(packetType = "C0FPacketConfirmTransaction")
            BlinkUtils.setBlinkState(packetTransaction = false)
        }
        if(FakeLagDisabler) {
            for (packet in packetBuffer) {
                PacketUtils.sendPacketNoEvent(packet)
            }
            packetBuffer.clear()
        }
    }

    fun debugMessage(str: String) {
        if (debugValue) {
            Chat.print("§f$str")
        }
    }


    @EventTarget
    fun onAttack(event: AttackEvent) {
        isOnCombat = true
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        isOnCombat = false
        if (vulcancombat) {
            BlinkUtils.clearPacket(packetType = "C0FPacketConfirmTransaction")
            currentTrans = 0
            updateLagTime()
            runReset = noC0BValue.get()
        }
    }
}
