/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.grim.GrimPlace
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.other.BasicDisabler
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.other.BasicDisabler.basicTypePrefix
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.other.FakeLagDisabler
import net.ccbluex.liquidbounce.script.api.global.Chat
import net.ccbluex.liquidbounce.value.*

object Disabler : Module("Disabler", Category.EXPLOIT, hideModule = false) {

    // Zdefiniowane tryby wyłączenia
    private val disablerModes = arrayOf(
        BasicDisabler,
        FakeLagDisabler,
        GrimPlace,
    )
    // Zbieranie nazw trybów
    private val modes = disablerModes.map { mode -> mode.modeName }.toTypedArray()

    val mode by object : MultiListValue("Mode", modes, emptyList()) {
        override fun onChange(oldValue: List<String>, newValue: List<String>): List<String> {
            if (newValue.isEmpty()) {
                onEnable()
            } else {
                onDisable()
            }
            return oldValue
        }
    }

    val fakeLagPosValue = BoolValue("FakeLag-Position", true) { mode.contains("FakeLag") }
    val fakeLagBlockValue = BoolValue("FakeLag-Block", true) {mode.contains("FakeLag")}
    val fakeLagAttackValue = BoolValue("FakeLag-Attack", true) {mode.contains("FakeLag")}
    val fakeLagSpoofValue = BoolValue("FakeLag-C03Spoof", false) {mode.contains("FakeLag")}
    val lagDelayValue = IntegerValue("FakeLag-LagDelay", 1, 1.. 2000) {mode.contains("FakeLag")}
    val lagDurationValue = IntegerValue("FakeLag-LagDuration", 200, 100.. 1000) {mode.contains("FakeLag")}

    val flagMode = ListValue("Flag-Mode", arrayOf("Edit", "Packet"), "Edit") {mode.contains("FlagDisabler")}
    val flagTick = IntegerValue("Flag-TickDelay", 25, 1.. 200) {mode.contains("FlagDisabler")}
    val flagSilent = BoolValue("Flag-SilentMode", true) {mode.contains("FlagDisabler")}


    val cancelC00Value by BoolValue("${basicTypePrefix}CancelC00", true) { mode.contains("BasicDisabler") }
    val cancelC0FValue by BoolValue("${basicTypePrefix}CancelC0F", true) { mode.contains("BasicDisabler") }
    val cancelC0AValue by BoolValue("${basicTypePrefix}CancelC0A", true) { mode.contains("BasicDisabler") }
    val cancelC0BValue by BoolValue("${basicTypePrefix}CancelC0B", true) { mode.contains("BasicDisabler") }
    val cancelC07Value by BoolValue("${basicTypePrefix}CancelC07", true) { mode.contains("BasicDisabler") }
    val cancelC13Value by BoolValue("${basicTypePrefix}CancelC13", true) { mode.contains("BasicDisabler") }
    val cancelC03Value by BoolValue("${basicTypePrefix}CancelC03", true) { mode.contains("BasicDisabler") }
    val c03NoMoveValue by BoolValue("${basicTypePrefix}C03-NoMove", true) { mode.contains("BasicDisabler") }

    val debugValue by BoolValue("Debug", false)

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val activeModes = modeModules
        for (disablerMode in activeModes) {
            disablerMode.onPacket(event)
        }
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        val activeModes = modeModules
        for (disablerMode in activeModes) {
            disablerMode.onUpdate()
        }
    }

    @EventTarget
    fun onMotion(event: MotionEvent) {
        val activeModes = modeModules
        for (disablerMode in activeModes) {
            disablerMode.onMotion()
        }
    }

    @EventTarget
    fun onTick(event: GameTickEvent) {
        val activeModes = modeModules
        for (disablerMode in activeModes) {
            disablerMode.onTick()
        }
    }

    @EventTarget
    fun onStrafe(event: StrafeEvent) {
        val activeModes = modeModules
        for (disablerMode in activeModes) {
            disablerMode.onStrafe()
        }
    }

    @EventTarget
    fun onAttack(event: AttackEvent) {
        val activeModes = modeModules
        for (disablerMode in activeModes) {
            disablerMode.onAttack()
        }
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        val activeModes = modeModules
        for (disablerMode in activeModes) {
            disablerMode.onWorld()
        }
    }

    override fun onEnable() {
        val activeModes = modeModules
        for (disablerMode in activeModes) {
            disablerMode.onEnable()
        }
    }

    override fun onDisable() {
        val activeModes = modeModules
        for (disablerMode in activeModes) {
            disablerMode.onDisable()
        }
    }

    fun debugMessage(str: String) {
        if (debugValue) {
            Chat.print("§f$str")
        }
    }

    private val modeModules
        get() = disablerModes.filter { mode.contains(it.modeName) }

    override val tag
        get() = mode.joinToString(" | ")

    override fun handleEvents() = super.handleEvents() && mc.thePlayer != null && mc.theWorld != null
}
